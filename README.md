# Avito тестовое задание для DevOps (2023)

## Содержание
- [Выполненные задания](#finish_tasks)
- [Структура и описание проекта](#project_descrption)
- [Описание конфигурации Golang приложения](#config_golang)
- [Описание конфигурации Nginx](#config_nginx)
- [Описание конфигурации Redis](#config_redis)
- [Описание работы с security.sh](#automaticly_security)
- [Настройка пароля вручную](#manual_security)
- [Описание работы с gen-certs.sh](#automaticly_certs)
- [Ручная настройка сертификатов](#manual_certs)
- [Запуск проекта в docker-compose](#run_project)

## <a name="finish_tasks"></a>Выполненные задания
- [x] В качестве базового образа используется Debian (используется debian:12.1-slim)
- [x] Развертывание приложения при помощи docker-compose версии 3.3 или старше (написан docker-compose и Dockerfile для всех сервисов)
- [x] Реализовано приложение на Golang
- [x] Работа в Redis происходит со строками (для удаления по ключу используется DEL)
- [x] На Redis поддержана аутентификация (аутентификация по заданному паролю и пользователю с помощью ACL)
- [x] Redis и приложение общаются по зашифрованному каналу (TLS-соединение).


## <a name="project_descrption"></a>Структура и описание проекта
```
├── docker-compose.yml
├── app
│   ├── RedisPass
│   ├── Dockerfile.goapp
│   └── main.go
├── nginx
│   ├── Dockerfile.nginx
│   └── nginx.conf
├── redis
│   ├── Dockerfile.redis
│   ├── users.acl
│   └── redis.conf
├── certs
├── security.sh
├── gen-certs.sh
└──README.md
```

- app/ - директория с Golang приложением, Dockerfile и файлом RedisPass (пароль для Redis)
- nginx/ - директория с конфигурацией и Dockerfile для запуска Nginx в контейнере 
- redis/ - директория с конфигурацией и Dockerfile для запуска REDIS в контейнере и файлом ACL 
- docker-compose - compose файл для запуска всех сервисов в контейнерах 
- certs - директория, где храняться сертификаты и ключи для работы TLS соединения
- security.sh - shell скрипт, используемый для генерации файла с паролем для Golang и конфига ACL для Redis 
- gen-certs.sh - shell скрипт, используемый для генерации сертификатов для защищенного соединения между приложением Golang и Redis

В качестве базового образа используется debian:12.1-slim во всех сервисах \
Приложение запускается и доступно по порту 8089 \
Запросы проксируются с nginx на Golang приложение, которое делает непосредственно запросы к Redis  \
К приложению необходимо обязательно сгенерировать пароли, сертификаты. В противном случае, приложение не будет работать

Приложение использует 3 эндпоинта: 
1. POST /set_key { "[key]": "[val]" } - добавление ключ-значение в REDIS
2. GET /get_key?key=[key] - добавление ключ-значение в REDIS
3. DELETE /del_key { "key": "[key]" } - удаление ключ-значение по ключу

## <a name="config_golang"></a>Описание конфигурации Golang приложения
Приложение Golang конфигурируется с помощью environment в docker-compose.yml
Список переменных окружения:
1. APP_PORT - порт приложения Golang. Пример задания ":8000". В начале обязательно указывать двоеточие. При изменении порта так же рекомендуется изменить значение EXPOSE в Dockerfile.goapp с Golang
2. REDIS_HOST - хост Redis с портом, на котором работает Redis. Пример: "redis-go:6379". Указывается в формате "хост:порт"
3. REDIS_USER - пользователь Redis, который используется для выполнения запросов к Redis. Пользователь по умолчанию "default" отключен. Подробнее про конфигурирование в "Описание работы с security.sh"
4. REDIS_PASS_FILE - путь до файла с паролем к Redis внутри контейнера. По умолчанию путь к файлу, смонтированным через docker secret. Подробнее про конфигурирование в [Описание работы с security.sh](#automaticly_security) и в [Настройка пароля вручную](#manual_security)
5. REDIS_CRT - путь до файла сертификата для Redis. По умолчанию путь к файлу указан, при монтировании через docker secret. Подробнее про конфигурирование в [Описание работы с gen-certs.sh](#automaticly_certs) и в [Ручная настройка сертификатов](#manual_certs)
6. REDIS_KEY - путь до файла с ключом для работы по TLS Redis. По умолчанию путь к файлу указан, при монтировании через docker secret. Подробнее про конфигурирование в [Описание работы с gen-certs.sh](#automaticly_certs) и в[Ручная настройка сертификатов](#manual_certs)

## <a name="config_nginx"></a>Описание Nginx конфигурации
Nginx проксирует все запросы по 3 endpoint к приложению Golang \
Обращение идет по DNS имени (имени сервиса) и объявлено в директиве upstream в nginx/nginx.conf \
По умолчанию используется имя сервиса goapp и следующая конфигурация: 
```
    upstream backend {
        server goapp:8000;
    }
```
В случае, если необходимо запустить приложение локально, либо будет использоваться другой сервер с приложением, необходимо заменить goapp на другой адрес \
Для изменения порта работы Nginx внутри контейнера необходимо внести правки в следующую строку:
```
listen 80 default_server;
```
80 - значение по умолчанию. При изменении стоит изменить EXPOSE в Dockerfile.nginx

## <a name="config_redis"></a>Описание Redis конфигурации
Обращения от Golang приложения идут к Redis \
Основные параметры для изменения в redis/redis.conf
1. bind - адрес, к которому будет привязан Redis 
2. port - порт, на котором функционирует REDIS сервер (По умолчанию: 6379). При изменении рекомендуется изменить EXPOSE в Dockerfile.redis
3. aclfile - путь до ACL файла с именем и паролем для пользователя Redis внутри контейнера
4. tls-cert-file - путь до файла с сертификатом внутри контейнера
5. tls-key-file - путь до файла с ключом внутри контейнера
6. tls-ca-cert-file - путь до файла с ca сертификатом внутри контейнера

## <a name="automaticly_security"></a>Описание работы с security.sh
Для корректной работы security.sh требуется установленный sha256. Запуск производить на OC Linux. \
security.sh предназначен для генерации файла с паролем пользователя для приложения Golang и для генерации ACL файла для Redis. \
Причины использования ACL для Redis вместо стандартного пользователя с паролем:
1. С помощью ACL в дальнейшем можно более детально настраивать доступы для пользователей Redis
2. С помощью ACL в файле можем хранить пароль в формате SHA256, что позволяет увеличить безопасность

После генерации файл с паролем для Golang и Redis монтируются в контейнеры с помощью secret, что позволяет избежать наличие пароля в args контейнера или в переменных окружения. \
Работа с security.sh: 
Пример генерации файла ACL и файла с паролем для приложения Golang
```
chmod +x security.sh
./security.sh gen_pass admin pass
```
- admin - имя пользователя, который будет иметь доступ в Redis
- pass - Пароль пользователя, который будет использован создаваемым пользователем в Redis
После работы завершения работы скрипта будет дополнен файл redis/users.acl пользователем с паролем в формате SHA256 и будет создан файл app/RedisPass с паролем для Redis

## <a name="manual_security"></a>Ручная настройка пароля
Если необходимо произвести ручную настройку пароля и доступа пользователя Redis необходимо сделать следующее:

1. Изменить файл users.acl добавив пользователя, его доступ к Redis и пароль (рекомендуется в формате SHA256)
2. Создать файл RedisPass в директории app и записать пароль к пользователю, указанному в redis/users.acl
3. Изменить пользователя для Golang приложения в переменных окружения в docker-compose

После внесения данных правок, можно запустить проект без помощи security.sh 
Монтирование паролей так же будет происходит через secret, что безопаснее, чем через переменные окружения и args

## <a name="automaticly_certs"></a>Описание работы с gen-certs.sh
shell срипт генерации сертификатов является измененным скриптом из репозитория Redis: https://raw.githubusercontent.com/redis/redis/unstable/utils/gen-test-certs.sh \
Предварительно на устройстве с Linux должен быть установлен openssl для корректной работы скрипта \
Данный shell скрипт предназначен для генерации сертификатов и ключей для работы TLS между Golang приложения и Redis \
Запуск скрипта:
```
chmod +x gen-certs.sh
./gen-certs.sh
```
После запуска скрипта будут сгенерированы ключи и сертификаты для работы Golang приложения и Redis по TLS \
Все ключи и сертификаты монтируются через secret, что безопаснее чем использование переменных окружения или volume

## <a name="manual_certs"></a>Ручная настройка сертификатов
При ручной настройки сертификатов необходимо внимательно настраивать все переменные и пути до сертификатов в docker-compose и других конфигурациях (redis), если изменения может затрагивать их работу. \
Так же рекомендуется обратить внимание где локально будут сохранены сертификаты. По умолчанию используются файлы с определенными, заданные в docker-compose в директории certs\
Если сертификаты и ключи были сгенерированы не с помощью get-certs.sh, необходимо их добавить в директорию certs и изменить их имена в docker-compose в разделе secrets и изменить переменные окружения для приложения Golang. Подробнее в [Описание конфигурации Golang приложения](#config_golang)

## <a name="run_project"></a>Запуск проекта в docker-compose
Для запуска проекта локально необходимо:

1. Установленный Docker, docker-compose 
Если данное ПО не установлено, необходимо обратиться к официальной документации: https://docs.docker.com/engine/install/

2. Установленный Git. Если не установлен, обратиться к официальной документации: https://git-scm.com/downloads

3. Установленный sha256 для генерации хэша пароля

4. Установленный openssl для генерации сертификатов и ключен

5. Установленный curl для проверки корректности работы приложения (опционально)


Далее будет приведен пример запуска приложения на Linux, используемый дистрибутив: Ubuntu 20.04 

Клонируем проект с Git и перейдем в директорию с проектом:
```
git clone https://github.com/baranovr605/avito-internship-devops.git
cd avito-internship-devops
```

Сконфигурируем пароли:
```
chmod +x security.sh
./security.sh gen_pass admin pass
```

Сгенерируем сертификаты:
```
chmod +x gen-certs.sh
./gen-certs.sh
```

Запустим проект средствами docker-compose в фоновом режиме:
```
docker-compose up -d
```

Если все успешно в консоли увидим следующие строки:
```
Creating redis-go ... done
Creating nginx-go ... done
Creating goapp    ... done
```

Можно провести проверку работы приложения. \
Ниже представлен пример с записью ключ-значение, получение данных по ключу и удаление ключа:
```
# curl -X POST localhost:8089/set_key -H "Content-Type: application/json" -d '{"test-var": "test-key"}'
Key-val correctly write in redis!
# curl -X GET localhost:8089/get_key?key=test-var
test-key
# curl -X DELETE localhost:8089/del_key -H "Content-Type: application/json" -d '{"test-var": "test-key"}'
Key correctly deleted!
# curl -X GET localhost:8089/get_key?key-test-var
404 page not found
```

Выполним дополнительную проверку что приложение и Redis общается по TLS. \
Для этого выполним следующие действия:
1. Зайдем в контейнер с redis и установим tcpdump для перехвата трафика
2. Выполним любой запрос с хостовой машины
3. Скопируем файл с дампом (.pcap) на хостовую машину
4. С помощью tshark просмотрим содержимое файла

Ниже представлен пример с перехваченным трафиком после SET запроса:
```
# tshark -r redis.pcap
    1   0.000000   172.27.0.3 → 172.27.0.2   TLSv1.2 120 Application Data
    2   0.000172   172.27.0.2 → 172.27.0.3   TLSv1.2 93 Application Data
    3   0.000184   172.27.0.3 → 172.27.0.2   TCP 66 58188 → 6379 [ACK] Seq=55 Ack=28 Win=501 Len=0 TSval=2024649914 TSecr=3619306745
    4   0.687076   172.27.0.3 → 172.27.0.2   TLSv1.2 120 Application Data
    5   0.687161   172.27.0.2 → 172.27.0.3   TLSv1.2 93 Application Data
    6   0.687171   172.27.0.3 → 172.27.0.2   TCP 66 58188 → 6379 [ACK] Seq=109 Ack=55 Win=501 Len=0 TSval=2024650601 TSecr=3619307432

```
Можно заметить что устанавливается TLS соединение с версией 1.2. Следовательно, шифрование трафика работает корректно и приложение и Redis общаются по зашифрованному каналу